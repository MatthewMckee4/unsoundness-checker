---
source: crates/unsoundness_checker/tests/markdown_test.rs
expression: combined_output
---
### Basic TYPE_CHECKING with else

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> Basic TYPE_CHECKING with else.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     def get_value() -> int:
5 |         ...
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING for imports

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING for imports.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     from expensive_module import ExpensiveClass
5 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with class definition

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with class definition.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     class MyClass:
5 |         value: int
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with variable annotation

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with variable annotation.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     value: int = 0
5 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### Nested TYPE_CHECKING blocks

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> Nested TYPE_CHECKING blocks.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     if True:
5 |         x: int = 0
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING in class body

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING in class body.py:4:8
  |
3 | class Container:
4 |     if TYPE_CHECKING:
  |        ^^^^^^^^^^^^^
5 |         data: int
6 |     else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with function overload

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with function overload.py:3:4
  |
1 | from typing import TYPE_CHECKING, overload
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     @overload
5 |     def process(x: int) -> str: ...
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with type alias

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with type alias.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     Data = dict[str, int]
5 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with multiple definitions

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with multiple definitions.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     def foo() -> int: ...
5 |     def bar() -> str: ...
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with global variable

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with global variable.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     CONSTANT: int = 0
5 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING in module level

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING in module level.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     import json as json_module
5 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with method

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with method.py:4:8
  |
3 | class Handler:
4 |     if TYPE_CHECKING:
  |        ^^^^^^^^^^^^^
5 |         def handle(self) -> int: ...
6 |     else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with conditional import

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with conditional import.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     from collections.abc import Sequence
5 |     def process(items: Sequence[int]) -> None: ...
  |
info: rule `if-type-checking-used` was selected in the configuration file


### TYPE_CHECKING with future import

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> TYPE_CHECKING with future import.py:4:4
  |
2 | from typing import TYPE_CHECKING
3 |
4 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
5 |     ComplexType = dict[str, list[int]]
6 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file


### Multiple TYPE_CHECKING blocks

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
 --> Multiple TYPE_CHECKING blocks.py:3:4
  |
1 | from typing import TYPE_CHECKING
2 |
3 | if TYPE_CHECKING:
  |    ^^^^^^^^^^^^^
4 |     x: int = 0
5 | else:
  |
info: rule `if-type-checking-used` was selected in the configuration file

error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.
  --> Multiple TYPE_CHECKING blocks.py:8:4
   |
 6 |     x: str = "zero"
 7 |
 8 | if TYPE_CHECKING:
   |    ^^^^^^^^^^^^^
 9 |     y: bool = True
10 | else:
   |
info: rule `if-type-checking-used` was selected in the configuration file
