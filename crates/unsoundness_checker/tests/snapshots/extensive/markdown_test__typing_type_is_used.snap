---
source: crates/unsoundness_checker/tests/markdown_test.rs
expression: combined_output
---
### Basic incorrect TypeIs

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:26
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_int(x: object) -> TypeIs[int]:
  |                          ^^^^^^^^^^^
4 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs always returning False

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:29
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_string(x: object) -> TypeIs[str]:
  |                             ^^^^^^^^^^^
4 |     return False
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs with wrong check

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:35
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_list_of_ints(x: object) -> TypeIs[list[int]]:
  |                                   ^^^^^^^^^^^^^^^^^
4 |     return isinstance(x, list)
  |
info: rule `typing-type-is-used` was selected in the configuration file


### Multiple TypeIs functions

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:26
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_int(x: object) -> TypeIs[int]:
  |                          ^^^^^^^^^^^
4 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:6:26
  |
4 |     return True
5 |
6 | def is_str(x: object) -> TypeIs[str]:
  |                          ^^^^^^^^^^^
7 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs in class method

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:5:35
  |
3 | class Validator:
4 |     @staticmethod
5 |     def is_positive(x: object) -> TypeIs[int]:
  |                                   ^^^^^^^^^^^
6 |         return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs with generic

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:6:27
  |
4 | T = TypeVar('T')
5 |
6 | def is_list(x: object) -> TypeIs[list[T]]:
  |                           ^^^^^^^^^^^^^^^
7 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs narrowing to wrong subtype

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
  --> main.py:10:26
   |
 8 |         pass
 9 |
10 | def is_dog(x: Animal) -> TypeIs[Dog]:
   |                          ^^^^^^^^^^^
11 |     return True
   |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs with union

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:33
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_int_or_str(x: object) -> TypeIs[int | str]:
  |                                 ^^^^^^^^^^^^^^^^^
4 |     return isinstance(x, bool)
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs in conditional

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:43
  |
1 | from typing_extensions import TypeIs
2 |
3 | def maybe_int(x: object, strict: bool) -> TypeIs[int]:
  |                                           ^^^^^^^^^^^
4 |     return True if strict else False
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs with complex type

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:35
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_dict_str_int(x: object) -> TypeIs[dict[str, int]]:
  |                                   ^^^^^^^^^^^^^^^^^^^^^^
4 |     return isinstance(x, dict)
  |
info: rule `typing-type-is-used` was selected in the configuration file


### Nested TypeIs checks

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:26
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_int(x: object) -> TypeIs[int]:
  |                          ^^^^^^^^^^^
4 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:6:35
  |
4 |     return True
5 |
6 | def is_positive_int(x: object) -> TypeIs[int]:
  |                                   ^^^^^^^^^^^
7 |     return is_int(x)
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs with Protocol

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:6:31
  |
4 |     def draw(self) -> None: ...
5 |
6 | def is_drawable(x: object) -> TypeIs[Drawable]:
  |                               ^^^^^^^^^^^^^^^^
7 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs in lambda (if possible)


### TypeIs with Literal

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:4:27
  |
2 | from typing import Literal
3 |
4 | def is_success(x: str) -> TypeIs[Literal["success"]]:
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
5 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs narrowing from Any

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:4:23
  |
2 | from typing_extensions import TypeIs
3 |
4 | def is_int(x: Any) -> TypeIs[int]:
  |                       ^^^^^^^^^^^
5 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### Multiple parameters with TypeIs

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:44
  |
1 | from typing_extensions import TypeIs
2 |
3 | def are_both_ints(x: object, y: object) -> TypeIs[int]:
  |                                            ^^^^^^^^^^^
4 |     return True
  |
info: rule `typing-type-is-used` was selected in the configuration file


### Correct TypeIs implementation

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:26
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_int(x: object) -> TypeIs[int]:
  |                          ^^^^^^^^^^^
4 |     return isinstance(x, int)
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs with proper validation

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
 --> main.py:3:35
  |
1 | from typing_extensions import TypeIs
2 |
3 | def is_list_of_ints(x: object) -> TypeIs[list[int]]:
  |                                   ^^^^^^^^^^^^^^^^^
4 |     return isinstance(x, list) and all(isinstance(i, int) for i in x)
  |
info: rule `typing-type-is-used` was selected in the configuration file


### TypeIs narrowing with isinstance

error[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.
  --> main.py:10:26
   |
 8 |         pass
 9 |
10 | def is_dog(x: Animal) -> TypeIs[Dog]:
   |                          ^^^^^^^^^^^
11 |     return isinstance(x, Dog)
   |
info: rule `typing-type-is-used` was selected in the configuration file
