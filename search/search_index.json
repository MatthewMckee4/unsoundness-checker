{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unsoundness Checker","text":""},{"location":"configuration/","title":"Configuration","text":"<p>To Enable / Disable rules, you can do the following</p> <pre><code>[tool.unsoundness-checker.rules]\ntyping-any-used = \"ignore\"\n</code></pre>"},{"location":"rules/","title":"Rules","text":""},{"location":"rules/#invalid-function-defaults","title":"<code>invalid-function-defaults</code>","text":"<p> Default level: <code>error</code>. </p> <p>What it does</p> <p>Checks for invalid settings of the <code>__defaults__</code> attribute of a function.</p> <p>Why is this bad?</p> <p>Modifying the <code>__defaults__</code> attribute with types different to the parameters can lead to runtime type errors.</p> <p>Examples</p> <pre><code>def foo(x: int = 1) -&gt; int:\n    return x\n\nfoo.__defaults__ = (\"string\",)\nresult = foo()  # Returns \"string\" but type checker thinks it's int\n</code></pre> <p>See more</p>"},{"location":"rules/#invalid-overload-implementation","title":"<code>invalid-overload-implementation</code>","text":"<p> Default level: <code>error</code>. </p> <p>What it does</p> <p>Checks for invalid overload implementation.</p> <p>Why is this bad?</p> <p>Invalid overload implementation can lead to runtime errors.</p> <p>Examples</p> <pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n@overload\ndef foo(x: str) -&gt; int: ...\ndef foo(x: int | str) -&gt; int | str:\n    return x\n\nfoo(\"1\")\n</code></pre> <p>See more</p>"},{"location":"rules/#setting-function-code-attribute","title":"<code>setting-function-code-attribute</code>","text":"<p> Default level: <code>error</code>. </p> <p>What it does</p> <p>Checks for setting the <code>__code__</code> attribute of a function.</p> <p>Why is this bad?</p> <p>Modifying the <code>__code__</code> attribute allows runtime modification of function internals, which can bypass type checking and lead to runtime type errors. Type checkers cannot analyze or verify operations performed through code objects.</p> <p>Examples</p> <pre><code>def foo(x: int) -&gt; int:\n    return 1\n\ndef bar(x: str) -&gt; str:\n    return \"bar\"\n\nfoo.__code__ = bar.__code__\n# Now foo will return a string\n</code></pre> <p>See more</p>"},{"location":"rules/#if-type-checking-used","title":"<code>if-type-checking-used</code>","text":"<p> Default level: <code>warn</code>. </p> <p>What it does</p> <p>Checks for usage of <code>if TYPE_CHECKING:</code> blocks from the <code>typing</code> module.</p> <p>Why is this bad?</p> <p><code>TYPE_CHECKING</code> is <code>False</code> at runtime but <code>True</code> during static type checking. When used with an <code>else</code> clause where signatures don't match, the type checker validates against the <code>if TYPE_CHECKING</code> branch, but at runtime the <code>else</code> branch executes, causing runtime type errors that the type checker can't catch.</p> <p>Examples</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    def get_value() -&gt; int:\n        ...\nelse:\n    def get_value() -&gt; str:\n        return \"hello\"\n\nresult: int = get_value()  # Type checks, but returns str at runtime!\n</code></pre> <p>See more</p>"},{"location":"rules/#type-checking-directive-used","title":"<code>type-checking-directive-used</code>","text":"<p> Default level: <code>warn</code>. </p> <p>What it does</p> <p>Checks for usage of type checking directives in comments.</p> <p>Why is this bad?</p> <p>Type checking directives like <code># type: ignore</code> suppress type checker warnings, which can hide potential type errors that may lead to runtime failures. These directives bypass the safety guarantees that type checking provides.</p> <p>Examples</p> <pre><code># mypy / standard (PEP 484)\nx = \"string\" + 123  # type: ignore\ny = foo()  # type: ignore[attr-defined]\n</code></pre> <p>See more</p>"},{"location":"rules/#typing-any-used","title":"<code>typing-any-used</code>","text":"<p> Default level: <code>warn</code>. </p> <p>What it does</p> <p>Checks for usage of <code>typing.Any</code> in type annotations.</p> <p>Why is this bad?</p> <p>Using <code>typing.Any</code> in type annotations can lead to runtime errors.</p> <p>Examples</p> <pre><code>from typing import Any\n\ndef foo(x: Any) -&gt; Any:\n    return x + 1\n\nfoo(\"1\")\n</code></pre> <p>See more</p>"},{"location":"rules/#typing-overload-used","title":"<code>typing-overload-used</code>","text":"<p> Default level: <code>warn</code>. </p> <p>What it does</p> <p>Checks for usage of overloaded functions.</p> <p>Why is this bad?</p> <p>Using overloaded functions can lead to runtime errors. When users don't follow the correct overload implementation, it can lead to unexpected behavior.</p> <p>Examples</p> <pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n@overload\ndef foo(x: str) -&gt; int: ...\ndef foo(x: int | str) -&gt; int | str:\n    return x\n</code></pre> <p>See more</p>"},{"location":"rules/if_type_checking_used/","title":"If TYPE_CHECKING used","text":"<p>Detects usage of <code>if TYPE_CHECKING:</code> blocks from the <code>typing</code> module.</p> <p><code>TYPE_CHECKING</code> is <code>False</code> at runtime but <code>True</code> during static type checking. This creates a disconnect between type checking and runtime behavior that can cause errors.</p>"},{"location":"rules/if_type_checking_used/#why-this-is-bad","title":"Why this is bad","text":"<p>The most dangerous pattern is using <code>if TYPE_CHECKING</code> with an <code>else</code> clause where signatures don't match:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    def get_value() -&gt; int:\n        ...\nelse:\n    def get_value() -&gt; str:\n        return \"hello\"\n</code></pre> Unsoundness Checker Output <pre><code>error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.\n --&gt; snippet_01.py:3:4\n  |\n1 | from typing import TYPE_CHECKING\n2 |\n3 | if TYPE_CHECKING:\n  |    ^^^^^^^^^^^^^\n4 |     def get_value() -&gt; int:\n5 |         ...\n  |\ninfo: rule `if-type-checking-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    TIMEOUT: int = 30\nelse:\n    TIMEOUT: str = \"30\"\n</code></pre> Unsoundness Checker Output <pre><code>error[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.\n --&gt; snippet_02.py:3:4\n  |\n1 | from typing import TYPE_CHECKING\n2 |\n3 | if TYPE_CHECKING:\n  |    ^^^^^^^^^^^^^\n4 |     TIMEOUT: int = 30\n5 | else:\n  |\ninfo: rule `if-type-checking-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/invalid_function_defaults/","title":"Accessing <code>__defaults__</code> attribute","text":"<p>Detects accessing the <code>__defaults__</code> attribute of a function, which can bypass type checking and lead to runtime type errors.</p> <p>The <code>__defaults__</code> attribute stores the default values for a function's parameters. When you modify this attribute directly, type checkers cannot verify that the new defaults match the expected parameter types, potentially causing type errors at runtime.</p>"},{"location":"rules/invalid_function_defaults/#what-gets-flagged","title":"What gets flagged","text":"<pre><code>def foo(x: int = 1) -&gt; int:\n    return x\n\nfoo.__defaults__ = (\"string\",)\n\nfoo.__defaults__ = None\n\ndef bar(x: int = 1, y: str = \"string\", z: bool = True) -&gt; int:\n    return x\n\nbar.__defaults__ = (1, \"string\", \"string\")\n\nbar.__defaults__ = None\n\nbar.__defaults__ = (1, \"string\")\n</code></pre> Unsoundness Checker Output <pre><code>error[invalid-function-defaults]: Setting `__defaults__` to an object of type `tuple[Literal[\"string\"]]` on a function may lead to runtime type errors.\n --&gt; snippet_01.py:4:1\n  |\n2 |     return x\n3 |\n4 | foo.__defaults__ = (\"string\",)\n  | ^^^^^^^^^^^^^^^^\n5 |\n6 | foo.__defaults__ = None\n  |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `None` on a function may lead to runtime type errors.\n --&gt; snippet_01.py:6:1\n  |\n4 | foo.__defaults__ = (\"string\",)\n5 |\n6 | foo.__defaults__ = None\n  | ^^^^^^^^^^^^^^^^\n7 |\n8 | def bar(x: int = 1, y: str = \"string\", z: bool = True) -&gt; int:\n  |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `tuple[Literal[1], Literal[\"string\"], Literal[\"string\"]]` on a function may lead to runtime type errors.\n  --&gt; snippet_01.py:11:1\n   |\n 9 |     return x\n10 |\n11 | bar.__defaults__ = (1, \"string\", \"string\")\n   | ^^^^^^^^^^^^^^^^\n12 |\n13 | bar.__defaults__ = None\n   |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `None` on a function may lead to runtime type errors.\n  --&gt; snippet_01.py:13:1\n   |\n11 | bar.__defaults__ = (1, \"string\", \"string\")\n12 |\n13 | bar.__defaults__ = None\n   | ^^^^^^^^^^^^^^^^\n14 |\n15 | bar.__defaults__ = (1, \"string\")\n   |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `tuple[Literal[1], Literal[\"string\"]]` on a function may lead to runtime type errors.\n  --&gt; snippet_01.py:15:1\n   |\n13 | bar.__defaults__ = None\n14 |\n15 | bar.__defaults__ = (1, \"string\")\n   | ^^^^^^^^^^^^^^^^\n   |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>We currently do not emit an error for this case, in future we will not</p> <p>We do not emit errors if the types of the new defaults match the expected parameter types.</p> <pre><code>def foo(x: str = \"string\") -&gt; str:\n    return x\n\n# This is type safe\nfoo.__defaults__ = (\"another_string\",)\n\nfoo.__defaults__ = (\"another_string\", \"another_string\")\n\ndef bar(x: int): ...\n\nbar.__defaults__ = (1,)\n\ndef baz(x: int): ...\n\nbaz.__defaults__ = None\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/invalid_overload_implementation/","title":"Invalid overload implementation","text":""},{"location":"rules/invalid_overload_implementation/#valid-overloads","title":"Valid Overloads","text":"<pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n@overload\ndef foo(x: str) -&gt; int: ...\ndef foo(x: int | str) -&gt; str | int:\n    if isinstance(x, int):\n        return str(x)\n    return len(x)\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <pre><code>from typing import overload\n\n@overload\ndef foo(x: int, y: str) -&gt; bool: ...\n@overload\ndef foo(x: str, y: int) -&gt; float: ...\ndef foo(x: int | str, y: str | int) -&gt; bool | float:\n    if isinstance(x, int) and isinstance(y, str):\n        return True\n    return 1.0\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/invalid_overload_implementation/#invalid-overloads-implementations","title":"Invalid Overloads Implementations","text":""},{"location":"rules/invalid_overload_implementation/#what-we-can-catch","title":"What we can catch","text":"<p>We emit diagnostics for return types that are not assignable to the union of the overload return types.</p> <p>The main issue that type checkers won't always pick up on is that the implementation return type can simply be <code>object</code> which everything is assignable to.</p> <pre><code>from typing import overload\n\n@overload\ndef bar(x: int) -&gt; str: ...\n@overload\ndef bar(x: str) -&gt; int: ...\ndef bar(x: int | str) -&gt; object:\n    return b\"\"\n</code></pre> Unsoundness Checker Output <pre><code>error[invalid-overload-implementation]: Invalid overload implementation can lead to runtime errors.\n --&gt; snippet_03.py:8:5\n  |\n6 | def bar(x: str) -&gt; int: ...\n7 | def bar(x: int | str) -&gt; object:\n8 |     return b\"\"\n  |     ^^^^^^^^^^\n  |\ninfo: This overload implementation is invalid as `Literal[b\"\"]` is not assignable to any of the overload return types (`str`, `int`)\ninfo: rule `invalid-overload-implementation` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>A side note is that if you changed the return type of <code>bar</code> implementation to <code>int | str</code>, then most type checkers would catch this error.</p> <pre><code>from typing import overload\n\n@overload\ndef bar(x: int) -&gt; str: ...\n@overload\ndef bar(x: str) -&gt; int: ...\ndef bar(x: int | str) -&gt; int | str:\n    return b\"\"\n</code></pre> Unsoundness Checker Output <pre><code>error[invalid-overload-implementation]: Invalid overload implementation can lead to runtime errors.\n --&gt; snippet_04.py:8:5\n  |\n6 | def bar(x: str) -&gt; int: ...\n7 | def bar(x: int | str) -&gt; int | str:\n8 |     return b\"\"\n  |     ^^^^^^^^^^\n  |\ninfo: This overload implementation is invalid as `Literal[b\"\"]` is not assignable to any of the overload return types (`str`, `int`)\ninfo: rule `invalid-overload-implementation` was selected in the configuration file\n</code></pre> Mypy Output <pre><code>&lt;temp_dir&gt;/snippet_04.py:8: error: Incompatible return value type (got \"bytes\", expected \"int | str\")  [return-value]\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> Pyright Output <pre><code>&lt;temp_dir&gt;/snippet_04.py\n  &lt;temp_dir&gt;/snippet_04.py:8:12 - error: Type \"Literal[b\"\"]\" is not assignable to return type \"int | str\"\n  \u00a0\u00a0Type \"Literal[b\"\"]\" is not assignable to type \"int | str\"\n  \u00a0\u00a0\u00a0\u00a0\"Literal[b\"\"]\" is not assignable to \"int\"\n  \u00a0\u00a0\u00a0\u00a0\"Literal[b\"\"]\" is not assignable to \"str\" (reportReturnType)\n1 error, 0 warnings, 0 informations\n</code></pre>"},{"location":"rules/invalid_overload_implementation/#what-we-cant-catch","title":"What we can't catch","text":"<p>Due to more complex examples, we currently can't catch all invalid overload implementations.</p> <p>The idea for the implementation of this was that at each return statement if all input variables had been narrowed to the types of the matching overload statement, then this would be a valid implementation.</p> <p>This is a obvious incorrect implementation.</p> <pre><code>from typing import overload\n\n@overload\ndef baz(x: int) -&gt; str: ...\n@overload\ndef baz(x: str) -&gt; int: ...\ndef baz(x: int | str) -&gt; int | str:\n    return x\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>This is a more complex example which makes it very difficult to catch any errors. this is a valid implementation, but because we lost information about the use of <code>x</code>, we cannot make any assumptions about if this is valid or not.</p> <p>And because we don't want to emit false positives, we will emit anything here.</p> <pre><code>from typing import overload, TypeVar\n\nT = TypeVar(\"T\")\n\ndef custom_copy(x: T) -&gt; T:\n    return x\n\n@overload\ndef baz(x: list[int]) -&gt; str: ...\n@overload\ndef baz(x: str) -&gt; int: ...\ndef baz(x: list[int] | str) -&gt; int | str:\n    # Some complex function that loses information about the type of x, and how it is used\n    y = custom_copy(x)\n    if isinstance(y, list):\n        return \"\"\n    else:\n        return 1\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/setting_function_code_attribute/","title":"Setting <code>__code__</code> attribute","text":"<p>Detects setting the <code>__code__</code> attribute of a function, which can bypass type checking and lead to runtime type errors.</p> <p>The <code>__code__</code> attribute contains the compiled bytecode of a function. When you modify this attribute directly, you can completely change the function's behavior, including its parameter types and return type, without the type checker being aware of the change.</p>"},{"location":"rules/setting_function_code_attribute/#what-gets-flagged","title":"What gets flagged","text":""},{"location":"rules/setting_function_code_attribute/#setting-__code__","title":"Setting <code>__code__</code>","text":"<pre><code>def foo(x: int) -&gt; int:\n    return 1\n\ndef bar(x: str) -&gt; str:\n    return \"!\"\n\nfoo.__code__ = bar.__code__\n\n# Type checker things `result` is an `int`, but it is a string\nresult = foo(10)\n</code></pre> Unsoundness Checker Output <pre><code>error[setting-function-code-attribute]: Setting `__code__` attribute on a function may lead to runtime type errors.\n --&gt; snippet_01.py:7:1\n  |\n5 |     return \"!\"\n6 |\n7 | foo.__code__ = bar.__code__\n  | ^^^^^^^^^^^^\n8 |\n9 | # Type checker things `result` is an `int`, but it is a string\n  |\ninfo: rule `setting-function-code-attribute` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/type_checking_directive_used/","title":"Type checking directive used","text":"<p>Detects usage of type checking directives in comments, which suppress type checker warnings and may hide potential type errors.</p> <p>Type checking directives like <code># type: ignore</code> tell type checkers to skip validation of specific lines or sections of code. While sometimes necessary, they can mask real bugs that would otherwise be caught during static analysis.</p>"},{"location":"rules/type_checking_directive_used/#what-gets-flagged","title":"What gets flagged","text":"<p>We detect directives from the major Python type checkers:</p>"},{"location":"rules/type_checking_directive_used/#mypy-standard-pep-484","title":"mypy / Standard (PEP 484)","text":"<pre><code># Blanket ignore - suppresses all type errors on this line\nresult = unsafe_operation()  # type: ignore\n\n# Specific error code - suppresses only specific error types\nx = get_value()  # type: ignore[attr-defined]\ny = compute()  # type: ignore[arg-type]\n</code></pre> Unsoundness Checker Output <pre><code>error[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_01.py:2:30\n  |\n1 | # Blanket ignore - suppresses all type errors on this line\n2 | result = unsafe_operation()  # type: ignore\n  |                              ^^^^^^^^^^^^^^\n3 |\n4 | # Specific error code - suppresses only specific error types\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nerror[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_01.py:5:18\n  |\n4 | # Specific error code - suppresses only specific error types\n5 | x = get_value()  # type: ignore[attr-defined]\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n6 | y = compute()  # type: ignore[arg-type]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nerror[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_01.py:6:16\n  |\n4 | # Specific error code - suppresses only specific error types\n5 | x = get_value()  # type: ignore[attr-defined]\n6 | y = compute()  # type: ignore[arg-type]\n  |                ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>"},{"location":"rules/type_checking_directive_used/#pyright","title":"pyright","text":"<pre><code># Blanket ignore\ndata = risky_call()  # pyright: ignore\n\n# Specific report type\nvalue = process()  # pyright: ignore[reportOptionalMemberAccess]\nitem = fetch()  # pyright: ignore[reportGeneralTypeIssues]\n</code></pre> Unsoundness Checker Output <pre><code>error[type-checking-directive-used]: Type checking directive `pyright: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_02.py:2:22\n  |\n1 | # Blanket ignore\n2 | data = risky_call()  # pyright: ignore\n  |                      ^^^^^^^^^^^^^^^^^\n3 |\n4 | # Specific report type\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nerror[type-checking-directive-used]: Type checking directive `pyright: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_02.py:5:20\n  |\n4 | # Specific report type\n5 | value = process()  # pyright: ignore[reportOptionalMemberAccess]\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n6 | item = fetch()  # pyright: ignore[reportGeneralTypeIssues]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nerror[type-checking-directive-used]: Type checking directive `pyright: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_02.py:6:17\n  |\n4 | # Specific report type\n5 | value = process()  # pyright: ignore[reportOptionalMemberAccess]\n6 | item = fetch()  # pyright: ignore[reportGeneralTypeIssues]\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>"},{"location":"rules/type_checking_directive_used/#ty","title":"ty","text":"<pre><code>result = unsafe_operation()  # ty: ignore[unresolved-import]\ndata = get_data()  # ty: ignore[attr-defined]\n</code></pre> Unsoundness Checker Output <pre><code>error[type-checking-directive-used]: Type checking directive `ty: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_03.py:1:30\n  |\n1 | result = unsafe_operation()  # ty: ignore[unresolved-import]\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n2 | data = get_data()  # ty: ignore[attr-defined]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nerror[type-checking-directive-used]: Type checking directive `ty: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_03.py:2:20\n  |\n1 | result = unsafe_operation()  # ty: ignore[unresolved-import]\n2 | data = get_data()  # ty: ignore[attr-defined]\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>"},{"location":"rules/type_checking_directive_used/#pyrefly","title":"pyrefly","text":"<pre><code>value = process()  # pyrefly: ignore[unused-import]\nitem = fetch()  # pyrefly: ignore[type-error]\n</code></pre> Unsoundness Checker Output <pre><code>error[type-checking-directive-used]: Type checking directive `pyrefly: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_04.py:1:20\n  |\n1 | value = process()  # pyrefly: ignore[unused-import]\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n2 | item = fetch()  # pyrefly: ignore[type-error]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nerror[type-checking-directive-used]: Type checking directive `pyrefly: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_04.py:2:17\n  |\n1 | value = process()  # pyrefly: ignore[unused-import]\n2 | item = fetch()  # pyrefly: ignore[type-error]\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>"},{"location":"rules/type_checking_directive_used/#why-this-matters","title":"Why this matters","text":"<p>Type checking directives bypass the safety guarantees that static type checking provides. For example:</p> <pre><code>def calculate_total(items: list[int]) -&gt; int:\n    return sum(items)\n\n# This will fail at runtime, but the directive hides the error\nresult = calculate_total(\"not a list\")  # type: ignore\n</code></pre> Unsoundness Checker Output <pre><code>error[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; snippet_05.py:5:41\n  |\n4 | # This will fail at runtime, but the directive hides the error\n5 | result = calculate_total(\"not a list\")  # type: ignore\n  |                                         ^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre> <p>Instead of suppressing the error, fix the underlying type issue:</p> <pre><code>def calculate_total(items: list[int]) -&gt; int:\n    return sum(items)\n\n# Correct the type to match the function signature\nresult = calculate_total([1, 2, 3])\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p>"},{"location":"rules/type_checking_directive_used/#when-directives-might-be-necessary","title":"When directives might be necessary","text":"<p>There are legitimate cases where type checking directives are needed: - Working with dynamic third-party libraries that lack type stubs - Handling complex metaprogramming that confuses type checkers - Temporary workarounds during incremental type adoption</p> <p>However, these should be rare and well-documented exceptions, not the norm.</p>"},{"location":"rules/typing_any_used/","title":"<code>typing.Any</code> used","text":"<p>Detects usage of <code>typing.Any</code> in type annotations, which can lead to runtime errors by bypassing type checking.</p> <p>When you use <code>Any</code>, you're essentially telling the type checker \"this could be anything,\" which defeats the purpose of having types in the first place. This can cause bugs that would otherwise be caught at development time.</p>"},{"location":"rules/typing_any_used/#what-gets-flagged","title":"What gets flagged","text":"<p>We currently detect <code>Any</code> in these places:</p>"},{"location":"rules/typing_any_used/#function-parameters","title":"Function parameters","text":"<pre><code>from typing import Any\n\ndef process_data(data: Any) -&gt; str:\n    return str(data)\n</code></pre> Unsoundness Checker Output <pre><code>error[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; snippet_01.py:3:24\n  |\n1 | from typing import Any\n2 |\n3 | def process_data(data: Any) -&gt; str:\n  |                        ^^^\n4 |     return str(data)\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/typing_any_used/#return-types","title":"Return types","text":"<pre><code>from typing import Any\n\ndef get_user_data() -&gt; Any:\n    return {\"name\": \"John\", \"age\": 30}\n</code></pre> Unsoundness Checker Output <pre><code>error[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; snippet_02.py:3:24\n  |\n1 | from typing import Any\n2 |\n3 | def get_user_data() -&gt; Any:\n  |                        ^^^\n4 |     return {\"name\": \"John\", \"age\": 30}\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/typing_any_used/#variable-assignments","title":"Variable assignments","text":"<pre><code>from typing import Any\n\ndef get_user() -&gt; dict[str, str | int]:\n    return {\"name\": \"John\", \"age\": 30}\n\nuser_info: Any = get_user()\n</code></pre> Unsoundness Checker Output <pre><code>error[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; snippet_03.py:6:12\n  |\n4 |     return {\"name\": \"John\", \"age\": 30}\n5 |\n6 | user_info: Any = get_user()\n  |            ^^^\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/typing_any_used/#why-this-matters","title":"Why this matters","text":"<p>Using <code>Any</code> removes type safety. For example:</p> <pre><code>from typing import Any\n\ndef calculate_total(items: Any) -&gt; int:\n    return sum(item for item in items)\n</code></pre> Unsoundness Checker Output <pre><code>error[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; snippet_04.py:3:28\n  |\n1 | from typing import Any\n2 |\n3 | def calculate_total(items: Any) -&gt; int:\n  |                            ^^^\n4 |     return sum(item for item in items)\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Instead, be specific about what you expect:</p> <pre><code>def calculate_total(items: list[int]) -&gt; int:\n    return sum(item for item in items)\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p>"},{"location":"rules/typing_overload_used/","title":"<code>typing.overload</code> used","text":"<p>Detects use of overloaded functions.</p> <p>Overloaded functions can often lead to runtime errors if the implementations are not consistent with the overload definitions.</p>"},{"location":"rules/typing_overload_used/#examples","title":"Examples","text":"<p>Here is an example of an overloaded function that is implemented correctly:</p> <pre><code>from typing import overload\n\n@overload\ndef add(a: int, b: int) -&gt; int: ...\n\n@overload\ndef add(a: float, b: float) -&gt; float: ...\n\ndef add(a: float, b: float) -&gt; float | int:\n    return a + b\n</code></pre> Unsoundness Checker Output <pre><code>error[typing-overload-used]: Using `typing.overload` can lead to runtime errors.\n --&gt; snippet_01.py:3:1\n  |\n1 | from typing import overload\n2 |\n3 | @overload\n  | ^^^^^^^^^\n4 | def add(a: int, b: int) -&gt; int: ...\n  |\ninfo: rule `typing-overload-used` was selected in the configuration file\n\nerror[typing-overload-used]: Using `typing.overload` can lead to runtime errors.\n --&gt; snippet_01.py:6:1\n  |\n4 | def add(a: int, b: int) -&gt; int: ...\n5 |\n6 | @overload\n  | ^^^^^^^^^\n7 | def add(a: float, b: float) -&gt; float: ...\n  |\ninfo: rule `typing-overload-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Whereas this one is not:</p> <pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n\n@overload\ndef foo(x: str) -&gt; int: ...\n\ndef foo(x: int | str) -&gt; str | int:\n    return x\n</code></pre> Unsoundness Checker Output <pre><code>error[typing-overload-used]: Using `typing.overload` can lead to runtime errors.\n --&gt; snippet_02.py:3:1\n  |\n1 | from typing import overload\n2 |\n3 | @overload\n  | ^^^^^^^^^\n4 | def foo(x: int) -&gt; str: ...\n  |\ninfo: rule `typing-overload-used` was selected in the configuration file\n\nerror[typing-overload-used]: Using `typing.overload` can lead to runtime errors.\n --&gt; snippet_02.py:6:1\n  |\n4 | def foo(x: int) -&gt; str: ...\n5 |\n6 | @overload\n  | ^^^^^^^^^\n7 | def foo(x: str) -&gt; int: ...\n  |\ninfo: rule `typing-overload-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>It is very hard for us to detect when an overloaded function is implemented incorrectly, so with this rule we can try to eliminate all uses of overloaded functions.</p>"}]}