{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Unsoundness Checker","text":"<p>We have a few aims with the tool and the site:</p> <ul> <li>To formally document unsoundness in the Python type system.</li> <li>To discuss why type checkers don't detect certain unsoundness.</li> <li>To provide a tool for detecting (some) unsoundness in Python code.</li> <li>To talk about the limitations of the tool.</li> </ul> <p>What is unsoundness (and soundness)?</p> <p>Type systems are considered sound when they can guarantee the absence of type errors at runtime. However, in Python, <code>TypeError</code>s can occur for various reasons, and the type system cannot prevent all of these cases.</p> <p>Most type checkers do a very good job of preventing most unsoundness, but there are still several cases where unsoundness can occur and users can run into <code>TypeError</code>s.</p>","path":["Unsoundness Checker"],"tags":[]},{"location":"#references","level":2,"title":"References","text":"<p>The Python type system is known to be partially unsound. And there have been some discussions about different examples of unsoundness.</p> <ul> <li>Discussion of examples of unsoundness</li> <li>Collection of examples of unsoundness</li> </ul> <p>It is important to note these resources. But they are trying to accomplish something different.</p> <p>Examples are useful to show how unsoundness can occur in code, but what we are trying to do here is categorise the different types of unsoundness.</p>","path":["Unsoundness Checker"],"tags":[]},{"location":"#acknowledgments","level":2,"title":"Acknowledgments","text":"<p>The core of this codebase is built on top of <code>ty</code> and <code>ruff</code>, the code from which is available at github.com/astral-sh/ruff.</p> <p>We use the <code>ruff</code> python parser.</p> <p>We use <code>ty</code> to infer the types of expressions and statements.</p> <p>We also take the structure of the rules from <code>ty</code>.</p>","path":["Unsoundness Checker"],"tags":[]},{"location":"#contributing","level":2,"title":"Contributing","text":"<p>This project is my 4th year individual project at the University of Glasgow. This repository is only public to show my progress. Please do not attempt to contribute to this.</p>","path":["Unsoundness Checker"],"tags":[]},{"location":"#submission","level":2,"title":"Submission","text":"<p>Below states how I need to submit my project.</p> <p>I must submit a zip file of all of my code, this can be done with the following command:</p> Bash<pre><code>zip -r archive.zip . -x 'target/*' -x '.git/*' -x 'dissertation/*';\n</code></pre>","path":["Unsoundness Checker"],"tags":[]},{"location":"categories/","level":1,"title":"Categories","text":"<p>This page describes the different categories of type system unsoundness that the checker can detect.</p>","path":["Categories"],"tags":[]},{"location":"categories/#runtime-modification","level":2,"title":"runtime-modification","text":"<p>Runtime code modifications that escape static type checker analysis.</p>","path":["Categories"],"tags":[]},{"location":"categories/#rules-in-this-category","level":3,"title":"Rules in this category","text":"<ul> <li><code>invalid-function-defaults</code> - detects invalid mutation of the <code>__defaults__</code> attribute of a function</li> <li><code>mutating-function-code-attribute</code> - detects mutating the <code>__code__</code> attribute of a function</li> <li><code>mutating-globals-dict</code> - detects mutations to the <code>globals()</code> dictionary</li> <li><code>mutable-generic-default</code> - detects mutable default arguments in generic functions</li> <li><code>invalid-setattr</code> - detects invalid usage of <code>setattr()</code> built-in function</li> </ul>","path":["Categories"],"tags":[]},{"location":"categories/#type-checking-suppression","level":2,"title":"type-checking-suppression","text":"<p>Mechanisms that suppress or bypass type checker warnings.</p>","path":["Categories"],"tags":[]},{"location":"categories/#rules-in-this-category_1","level":3,"title":"Rules in this category","text":"<ul> <li><code>typing-any-used</code> - detects usage of <code>typing.Any</code> in type annotations</li> <li><code>invalid-overload-implementation</code> - detects invalid overload implementation</li> <li><code>typing-overload-used</code> - detects usage of overloaded functions</li> <li><code>type-checking-directive-used</code> - detects usage of type checking directives in comments</li> <li><code>if-type-checking-used</code> - detects usage of <code>if TYPE_CHECKING:</code> blocks</li> <li><code>typing-cast-used</code> - detects usage of <code>typing.cast()</code> function calls</li> <li><code>typing-type-is-used</code> - detects usage of <code>typing.TypeIs</code> in return type annotations</li> <li><code>callable-ellipsis-used</code> - detects usage of <code>...</code> in the first argument of <code>Callable</code> type annotations</li> <li><code>mangled-dunder-instance-variable</code> - detects explicit usage of mangled dunder instance variables</li> </ul>","path":["Categories"],"tags":[]},{"location":"configuration/","level":1,"title":"Configuration","text":"<p>To Enable / Disable rules, you can do the following</p> TOML<pre><code>[tool.unsoundness-checker.rules]\ntyping-any-used = \"ignore\"\n</code></pre>","path":["Configuration"],"tags":[]},{"location":"rules/","level":1,"title":"Rules","text":"","path":["Rules"],"tags":[]},{"location":"rules/#invalid-function-defaults","level":2,"title":"<code>invalid-function-defaults</code>","text":"<p>What it does</p> <p>Checks for invalid mutations of the <code>__defaults__</code> attribute of a function.</p> <p>Why is this bad?</p> <p>Modifying the <code>__defaults__</code> attribute with types different to the parameters can lead to runtime type errors.</p> <p>Examples</p> Python<pre><code>def foo(x: int = 1) -&gt; int:\n    return x\n\nfoo.__defaults__ = (\"string\",)\nresult = foo()  # Returns \"string\" but type checker thinks it's int\n</code></pre> <p> Default level: <code>error</code>. </p> <p> Categories: <code>runtime-modification</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#invalid-overload-implementation","level":2,"title":"<code>invalid-overload-implementation</code>","text":"<p>What it does</p> <p>Checks for invalid overload implementation.</p> <p>Why is this bad?</p> <p>Invalid overload implementation can lead to runtime errors.</p> <p>Examples</p> Python<pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n@overload\ndef foo(x: str) -&gt; int: ...\ndef foo(x: int | str) -&gt; int | str:\n    return x\n\nfoo(\"1\")\n</code></pre> <p> Default level: <code>error</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#invalid-setattr","level":2,"title":"<code>invalid-setattr</code>","text":"<p>What it does</p> <p>Checks for invalid <code>setattr()</code> usage.</p> <p>Why is this bad?</p> <p><code>setattr()</code> bypasses type checking by allowing \"dynamic\" attribute assignment. You can assign any type to any attribute, which can lead to runtime type errors when the actual type doesn't match the declared type annotation.</p> <p>Examples</p> Python<pre><code>class Foo:\n    def __init__(self) -&gt; None:\n        self.x: str = \"hello\"\n\nfoo = Foo()\nsetattr(foo, \"x\", 1)\n</code></pre> <p> Default level: <code>error</code>. </p> <p> Categories: <code>runtime-modification</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#mutable-generic-default","level":2,"title":"<code>mutable-generic-default</code>","text":"<p>What it does</p> <p>Checks for generic functions or methods that accept mutable objects as default parameter values.</p> <p>Why is this bad?</p> <p>When a generic function uses a mutable default value (like a list, dict, or set), that default is shared across all invocations of the function. This creates a scenario where the mutable object can accumulate values of different types from different calls.</p> <p>Type checkers assume that <code>list[T]</code> only contains values of type <code>T</code>. However, when a mutable default is reused across calls with different type parameters, the list can contain values of multiple different types, leading to runtime type errors.</p> <p>Examples</p> Python<pre><code>def append_and_return[T](x: T, items: list[T] = []) -&gt; list[T]:\n    items.append(x)\n    return items\n\nint_list = append_and_return(42)\nstr_list = append_and_return(\"hello\")\n\n# This is a int at runtime but str at type check time.\nvalue: str = str_list[0]\n</code></pre> <p> Default level: <code>error</code>. </p> <p> Categories: <code>runtime-modification</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#mutating-function-code-attribute","level":2,"title":"<code>mutating-function-code-attribute</code>","text":"<p>What it does</p> <p>Checks for mutating the <code>__code__</code> attribute of a function.</p> <p>Why is this bad?</p> <p>Modifying the <code>__code__</code> attribute allows runtime modification of function internals, which can bypass type checking and lead to runtime type errors. Type checkers cannot analyze or verify operations performed through code objects.</p> <p>Examples</p> Python<pre><code>def foo(x: int) -&gt; int:\n    return 1\n\ndef bar(x: str) -&gt; str:\n    return \"bar\"\n\nfoo.__code__ = bar.__code__\n# Now foo will return a string\n</code></pre> <p> Default level: <code>error</code>. </p> <p> Categories: <code>runtime-modification</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#mutating-globals-dict","level":2,"title":"<code>mutating-globals-dict</code>","text":"<p>What it does</p> <p>Checks for mutations to the <code>globals()</code> dictionary.</p> <p>Why is this bad?</p> <p>Modifying the <code>globals()</code> dictionary allows runtime modification of global variables, which can bypass type checking and lead to runtime type errors. Type checkers cannot track or verify modifications made through the globals dictionary.</p> <p>Examples</p> Python<pre><code>x: int = 5\n\nglobals()['x'] = \"hello\"\n\n# Type checker thinks `x` is an `int`, but it is now a string\nresult: int = x\n</code></pre> <p> Default level: <code>error</code>. </p> <p> Categories: <code>runtime-modification</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#callable-ellipsis-used","level":2,"title":"<code>callable-ellipsis-used</code>","text":"<p>What it does</p> <p>Checks for usage of <code>...</code> (ellipsis) in the first argument of <code>Callable</code> type annotations.</p> <p>Why is this bad?</p> <p>Using <code>Callable[..., ReturnType]</code> indicates that the callable accepts any number of arguments of any type, which bypasses parameter type checking. This can lead to runtime type errors as the type checker cannot verify argument types or counts.</p> <p>Examples</p> Python<pre><code>from typing import Callable\n\ndef foo(callback: Callable[..., int]) -&gt; int:\n    return callback(\"wrong\", \"types\")\n\ndef bar(x: int) -&gt; int:\n    return x\n\n# This passes type checking but fails at runtime.\nfoo(bar)\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#if-type-checking-used","level":2,"title":"<code>if-type-checking-used</code>","text":"<p>What it does</p> <p>Checks for usage of <code>if TYPE_CHECKING:</code> blocks from the <code>typing</code> module.</p> <p>Why is this bad?</p> <p><code>TYPE_CHECKING</code> is <code>False</code> at runtime but <code>True</code> during static type checking. When used with an <code>else</code> clause where signatures don't match, the type checker validates against the <code>if TYPE_CHECKING</code> branch, but at runtime the <code>else</code> branch executes, causing runtime type errors that the type checker can't catch.</p> <p>Examples</p> Python<pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    def get_value() -&gt; int:\n        ...\nelse:\n    def get_value() -&gt; str:\n        return \"hello\"\n\nresult: int = get_value()  # Type checks, but returns str at runtime!\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#mangled-dunder-instance-variable","level":2,"title":"<code>mangled-dunder-instance-variable</code>","text":"<p>What it does</p> <p>Checks for explicit usage of mangled dunder instance variables in attribute access.</p> <p>Why is this bad?</p> <p>Python automatically mangles double-underscore (dunder) instance variables to <code>_ClassName__variable</code> to provide name privacy. When code explicitly uses the mangled form, it can bypass type checking by assigning different types to the mangled name than what the non-mangled variable expects.</p> <p>Examples</p> Python<pre><code>class HiddenDunderVariables:\n    def __init__(self, x: int) -&gt; None:\n        self.__str_x = str(x)\n        self._HiddenDunderVariables__str_x = x\n\n    def get_str_x(self) -&gt; str:\n        return self.__str_x\n\n# Here, x is a string at type check time, but an integer at runtime.\nx = hidden_dunder_variables.get_str_x()\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#type-checking-directive-used","level":2,"title":"<code>type-checking-directive-used</code>","text":"<p>What it does</p> <p>Checks for usage of type checking directives in comments.</p> <p>Why is this bad?</p> <p>Type checking directives like <code># type: ignore</code> suppress type checker warnings, which can hide potential type errors that may lead to runtime failures. These directives bypass the safety guarantees that type checking provides.</p> <p>Examples</p> Python<pre><code># mypy / standard (PEP 484)\nx = \"string\" + 123  # type: ignore\ny = foo()  # type: ignore[attr-defined]\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#typing-any-used","level":2,"title":"<code>typing-any-used</code>","text":"<p>What it does</p> <p>Checks for usage of <code>typing.Any</code> in type annotations.</p> <p>Why is this bad?</p> <p>Using <code>typing.Any</code> in type annotations can lead to runtime errors.</p> <p>Examples</p> Python<pre><code>from typing import Any\n\ndef foo(x: Any) -&gt; Any:\n    return x + 1\n\nfoo(\"1\")\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#typing-cast-used","level":2,"title":"<code>typing-cast-used</code>","text":"<p>What it does</p> <p>Checks for usage of <code>typing.cast()</code> function calls.</p> <p>Why is this bad?</p> <p><code>typing.cast()</code> tells the type checker to treat a value as a specific type without any runtime checks or validation. This can lead to runtime type errors if the cast is incorrect. Type checkers trust casts completely, so incorrect casts bypass all type safety guarantees.</p> <p>Examples</p> Python<pre><code>from typing import cast\n\ndef get_value() -&gt; int | str:\n    return \"hello\"\n\nresult = cast(int, get_value())\nresult + 1  # Type checks, but fails at runtime!\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#typing-overload-used","level":2,"title":"<code>typing-overload-used</code>","text":"<p>What it does</p> <p>Checks for usage of overloaded functions.</p> <p>Why is this bad?</p> <p>Using overloaded functions can lead to runtime errors. When users don't follow the correct overload implementation, it can lead to unexpected behavior.</p> <p>Examples</p> Python<pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n@overload\ndef foo(x: str) -&gt; int: ...\ndef foo(x: int | str) -&gt; int | str:\n    return x\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/#typing-type-is-used","level":2,"title":"<code>typing-type-is-used</code>","text":"<p>What it does</p> <p>Checks for return types that use <code>typing.TypeIs</code>.</p> <p>Why is this bad?</p> <p>Using <code>typing.TypeIs</code> in return type annotations can lead to runtime type errors. Type checkers use <code>TypeIs</code> to narrow types, but incorrect implementation can bypass type safety guarantees.</p> <p>Examples</p> Python<pre><code>from typing import TypeIs\n\ndef is_int(x: object) -&gt; TypeIs[int]:\n    return True\n\nvalue = \"hello\"\n\nif is_int(value):\n    result = value + 1  # Type checks but fails at runtime!\n</code></pre> <p> Default level: <code>warn</code>. </p> <p> Categories: <code>type-checking-suppression</code>. </p> <p>See more</p>","path":["Rules"],"tags":[]},{"location":"rules/callable_ellipsis_used/","level":1,"title":"Ellipsis in Callable Type Annotations","text":"<p>Detects usage of <code>...</code> (ellipsis) in the first argument of <code>Callable</code> type annotations, which bypasses parameter type checking.</p> <p>Using <code>Callable[..., ReturnType]</code> indicates that the callable accepts any number of arguments of any type. The type checker cannot verify argument types or counts, which can lead to runtime errors.</p>","path":["Ellipsis in Callable Type Annotations"],"tags":[]},{"location":"rules/callable_ellipsis_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>from typing import Callable\n\ndef foo(callback: Callable[..., int]) -&gt; int:\n    return callback(\"wrong\", \"types\")\n\ndef bar(x: int) -&gt; int:\n    return x\n\n# This passes type checking but fails at runtime.\nfoo(bar)\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[callable-ellipsis-used]: Using `...` in `Callable` type annotations can lead to runtime type errors.\n --&gt; main.py:3:19\n  |\n1 | from typing import Callable\n2 |\n3 | def foo(callback: Callable[..., int]) -&gt; int:\n  |                   ^^^^^^^^^^^^^^^^^^\n4 |     return callback(\"wrong\", \"types\")\n  |\ninfo: rule `callable-ellipsis-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Ellipsis in Callable Type Annotations"],"tags":[]},{"location":"rules/if_type_checking_used/","level":1,"title":"If TYPE_CHECKING used","text":"<p>Detects usage of <code>if TYPE_CHECKING:</code> blocks from the <code>typing</code> module.</p> <p><code>TYPE_CHECKING</code> is <code>False</code> at runtime but <code>True</code> during static type checking. This creates a disconnect between type checking and runtime behavior that can cause errors.</p> <p>The most dangerous pattern is using <code>if TYPE_CHECKING</code> with an <code>else</code> clause where signatures don't match:</p>","path":["If TYPE_CHECKING used"],"tags":[]},{"location":"rules/if_type_checking_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    def get_value() -&gt; int:\n        ...\nelse:\n    def get_value() -&gt; str:\n        return \"hello\"\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[if-type-checking-used]: Using `if TYPE_CHECKING:` blocks can lead to runtime errors if imports or definitions are incorrectly referenced at runtime.\n --&gt; main.py:3:4\n  |\n1 | from typing import TYPE_CHECKING\n2 |\n3 | if TYPE_CHECKING:\n  |    ^^^^^^^^^^^^^\n4 |     def get_value() -&gt; int:\n5 |         ...\n  |\ninfo: rule `if-type-checking-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["If TYPE_CHECKING used"],"tags":[]},{"location":"rules/invalid_function_defaults/","level":1,"title":"Accessing <code>__defaults__</code> attribute","text":"<p>Detects accessing the <code>__defaults__</code> attribute of a function, which can bypass type checking and lead to runtime type errors.</p> <p>The <code>__defaults__</code> attribute stores the default values for a function's parameters. When you modify this attribute directly, type checkers cannot verify that the new defaults match the expected parameter types, potentially causing type errors at runtime.</p>","path":["Accessing __defaults__ attribute"],"tags":[]},{"location":"rules/invalid_function_defaults/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>def foo(x: int = 1) -&gt; int:\n    return x\n\nfoo.__defaults__ = (\"string\",)\n\nfoo.__defaults__ = None\n\ndef bar(x: int = 1, y: str = \"string\", z: bool = True) -&gt; int:\n    return x\n\nbar.__defaults__ = (1, \"string\", \"string\")\n\nbar.__defaults__ = None\n\nbar.__defaults__ = (1, \"string\")\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[invalid-function-defaults]: Setting `__defaults__` to an object of type `tuple[Literal[\"string\"]]` on a function may lead to runtime type errors.\n --&gt; main.py:4:1\n  |\n2 |     return x\n3 |\n4 | foo.__defaults__ = (\"string\",)\n  | ^^^^^^^^^^^^^^^^\n5 |\n6 | foo.__defaults__ = None\n  |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `None` on a function may lead to runtime type errors.\n --&gt; main.py:6:1\n  |\n4 | foo.__defaults__ = (\"string\",)\n5 |\n6 | foo.__defaults__ = None\n  | ^^^^^^^^^^^^^^^^\n7 |\n8 | def bar(x: int = 1, y: str = \"string\", z: bool = True) -&gt; int:\n  |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `tuple[Literal[1], Literal[\"string\"], Literal[\"string\"]]` on a function may lead to runtime type errors.\n  --&gt; main.py:11:1\n   |\n 9 |     return x\n10 |\n11 | bar.__defaults__ = (1, \"string\", \"string\")\n   | ^^^^^^^^^^^^^^^^\n12 |\n13 | bar.__defaults__ = None\n   |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `None` on a function may lead to runtime type errors.\n  --&gt; main.py:13:1\n   |\n11 | bar.__defaults__ = (1, \"string\", \"string\")\n12 |\n13 | bar.__defaults__ = None\n   | ^^^^^^^^^^^^^^^^\n14 |\n15 | bar.__defaults__ = (1, \"string\")\n   |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n\nerror[invalid-function-defaults]: Setting `__defaults__` to an object of type `tuple[Literal[1], Literal[\"string\"]]` on a function may lead to runtime type errors.\n  --&gt; main.py:15:1\n   |\n13 | bar.__defaults__ = None\n14 |\n15 | bar.__defaults__ = (1, \"string\")\n   | ^^^^^^^^^^^^^^^^\n   |\ninfo: rule `invalid-function-defaults` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Accessing __defaults__ attribute"],"tags":[]},{"location":"rules/invalid_function_defaults/#what-is-okay","level":2,"title":"What is okay","text":"<p>We do not emit errors if the types of the new defaults match the expected parameter types.</p> Python<pre><code>def foo(x: str = \"string\") -&gt; str:\n    return x\n\nfoo.__defaults__ = (\"another_string\",)\n\nfoo.__defaults__ = (\"another_string\", \"another_string\")\n\ndef bar(x: int): ...\n\nbar.__defaults__ = (1,)\n\ndef baz(x: int): ...\n\nbaz.__defaults__ = None\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Accessing __defaults__ attribute"],"tags":[]},{"location":"rules/invalid_overload_implementation/","level":1,"title":"Invalid overload implementation","text":"<p>We emit diagnostics for return types that are not assignable to the union of the overload return types.</p> <p>The main issue that type checkers won't always pick up on is that the implementation return type can simply be <code>object</code> which everything is assignable to.</p>","path":["Invalid overload implementation"],"tags":[]},{"location":"rules/invalid_overload_implementation/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>from typing import overload\n\n@overload\ndef bar(x: int) -&gt; str: ...\n@overload\ndef bar(x: str) -&gt; int: ...\ndef bar(x: int | str) -&gt; object:\n    return b\"\"\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[invalid-overload-implementation]: Invalid overload implementation can lead to runtime errors.\n --&gt; main.py:8:5\n  |\n6 | def bar(x: str) -&gt; int: ...\n7 | def bar(x: int | str) -&gt; object:\n8 |     return b\"\"\n  |     ^^^^^^^^^^\n  |\ninfo: This overload implementation is invalid as `Literal[b\"\"]` is not assignable to any of the overload return types (`str`, `int`)\ninfo: rule `invalid-overload-implementation` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p> <p>A side note is that if you changed the return type of <code>bar</code> implementation to <code>int | str</code>, then most type checkers would catch this error.</p>","path":["Invalid overload implementation"],"tags":[]},{"location":"rules/invalid_overload_implementation/#what-we-cant-catch","level":2,"title":"What we can't catch","text":"<p>Due to more complex examples, we currently can't catch all invalid overload implementations.</p> <p>The idea for the implementation of this was that at each return statement if all input variables had been narrowed to the types of the matching overload statement, then this would be a valid implementation.</p> <p>Due to complex scenarios of lost information, we cannot make any assumptions about if this is valid or not.</p> Python<pre><code>from typing import overload\n\n@overload\ndef baz(x: int) -&gt; str: ...\n@overload\ndef baz(x: str) -&gt; int: ...\ndef baz(x: int | str) -&gt; int | str:\n    return x\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p> <p>This is a more complex example which makes it very difficult to catch any errors. this is a valid implementation, but because we lost information about the use of <code>x</code>, we cannot make any assumptions about if this is valid or not.</p> <p>And because we don't want to emit false positives, we will not emit anything here.</p> Python<pre><code>from typing import overload, TypeVar\n\nT = TypeVar(\"T\")\n\ndef custom_copy(x: T) -&gt; T:\n    return x\n\n@overload\ndef baz(x: list[int]) -&gt; str: ...\n@overload\ndef baz(x: str) -&gt; int: ...\ndef baz(x: list[int] | str) -&gt; int | str:\n    # Some complex function that loses information about the type of x, and how it is used\n    y = custom_copy(x)\n    if isinstance(y, list):\n        return \"\"\n    else:\n        return 1\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Invalid overload implementation"],"tags":[]},{"location":"rules/invalid_setattr/","level":1,"title":"Invalid <code>setattr()</code> call","text":"<p>Detects invalid usage of <code>setattr()</code> built-in function, which bypasses type checking and can lead to runtime type errors.</p> <p><code>setattr()</code> allows dynamic attribute assignment, letting you assign any type to any attribute regardless of type annotations. Type checkers can't track these dynamic modifications.</p>","path":["Invalid setattr() call"],"tags":[]},{"location":"rules/invalid_setattr/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>class Foo:\n    def __init__(self) -&gt; None:\n        self.x: str = \"hello\"\n\nfoo = Foo()\nsetattr(foo, \"x\", 1)\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[invalid-setattr]: Using `setattr()` bypasses type checking and can lead to runtime type errors.\n --&gt; main.py:6:1\n  |\n5 | foo = Foo()\n6 | setattr(foo, \"x\", 1)\n  | ^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: Object of type Literal[1] is not assignable to type str\ninfo: rule `invalid-setattr` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Invalid setattr() call"],"tags":[]},{"location":"rules/mangled_dunder_instance_variable/","level":1,"title":"Mangled dunder instance variable used","text":"<p>Detects explicit usage of mangled dunder instance variables, which can bypass type checking and lead to runtime errors.</p> <p>Python automatically mangles double-underscore (dunder) instance variables to <code>_ClassName__variable</code> to provide name privacy. When code explicitly uses the mangled form, it can assign different types to the mangled name than what the non-mangled variable expects, breaking type safety.</p>","path":["Mangled dunder instance variable used"],"tags":[]},{"location":"rules/mangled_dunder_instance_variable/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>class HiddenDunderVariables:\n    def __init__(self, x: int) -&gt; None:\n        self.__str_x = str(x)\n        self._HiddenDunderVariables__str_x = x\n\n    def get_str_x(self) -&gt; str:\n        return self.__str_x\n\n\nhidden_dunder_variables = HiddenDunderVariables(42)\n\n# Type checker thinks this is a string, but at runtime it is an integer.\nx = hidden_dunder_variables.get_str_x()\n\n# We should also not be able to set it\nhidden_dunder_variables._HiddenDunderVariables__str_x = 1\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[mangled-dunder-instance-variable]: Explicit use of mangled attribute `_HiddenDunderVariables__str_x` can bypass type checking and lead to runtime type errors.\n --&gt; main.py:4:9\n  |\n2 |     def __init__(self, x: int) -&gt; None:\n3 |         self.__str_x = str(x)\n4 |         self._HiddenDunderVariables__str_x = x\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n5 |\n6 |     def get_str_x(self) -&gt; str:\n  |\ninfo: rule `mangled-dunder-instance-variable` was selected in the configuration file\n\nwarning[mangled-dunder-instance-variable]: Explicit use of mangled attribute `_HiddenDunderVariables__str_x` can bypass type checking and lead to runtime type errors.\n  --&gt; main.py:16:1\n   |\n15 | # We should also not be able to set it\n16 | hidden_dunder_variables._HiddenDunderVariables__str_x = 1\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\ninfo: rule `mangled-dunder-instance-variable` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p> <p>In this example, <code>self.__str_x</code> is first assigned a string value <code>str(x)</code>. However, the explicit use of the mangled name <code>self._HiddenDunderVariables__str_x</code> then assigns an integer <code>x</code> to the same underlying variable. This overwrites the string with an integer, causing the type checker to miss the error since it sees these as separate assignments.</p>","path":["Mangled dunder instance variable used"],"tags":[]},{"location":"rules/mutable_generic_default/","level":1,"title":"Mutable default argument in generic function","text":"<p>Detects when a generic function or method accepts a mutable object as a default parameter value, which can lead to runtime type errors.</p> <p>When a generic function uses a mutable default value (like a list, dict, or set), that default is shared across all invocations of the function. This creates a scenario where the mutable object can accumulate values of different types from different calls.</p>","path":["Mutable default argument in generic function"],"tags":[]},{"location":"rules/mutable_generic_default/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>def append_and_return[T](x: T, y: list[T] = []) -&gt; list[T]:\n    y.append(x)\n    return y\n\n# Each call with a different type shares the same list\nint_list = append_and_return(1)\nstr_list = append_and_return(\"hello\")\n\n# This is a int at runtime but str at type check time.\nvalue = str_list[0]\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[mutable-generic-default]: Using a mutable default argument for a generic parameter in a function can lead to runtime type errors.\n --&gt; main.py:1:45\n  |\n1 | def append_and_return[T](x: T, y: list[T] = []) -&gt; list[T]:\n  |                                             ^^\n2 |     y.append(x)\n3 |     return y\n  |\ninfo: rule `mutable-generic-default` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p> <p>In this example, both calls to <code>append_and_return</code> share the same default list. If code appends to this list in different calls with different type parameters, the list ends up containing mixed types, breaking the type soundness that <code>list[T]</code> promises.</p>","path":["Mutable default argument in generic function"],"tags":[]},{"location":"rules/mutating_function_code_attribute/","level":1,"title":"Mutating <code>__code__</code> attribute","text":"<p>Detects setting the <code>__code__</code> attribute of a function, which can bypass type checking and lead to runtime type errors.</p> <p>The <code>__code__</code> attribute contains the compiled bytecode of a function. When you modify this attribute directly, you can completely change the function's behavior, including its parameter types and return type, without the type checker being aware of the change.</p>","path":["Mutating __code__ attribute"],"tags":[]},{"location":"rules/mutating_function_code_attribute/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>def foo(x: int) -&gt; int:\n    return 1\n\ndef bar(x: str) -&gt; str:\n    return \"!\"\n\nfoo.__code__ = bar.__code__\n\n# Type checker things `result` is an `int`, but it is a string\nresult = foo(10)\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[mutating-function-code-attribute]: Mutating `__code__` attribute on a function may lead to runtime type errors.\n --&gt; main.py:7:1\n  |\n5 |     return \"!\"\n6 |\n7 | foo.__code__ = bar.__code__\n  | ^^^^^^^^^^^^\n8 |\n9 | # Type checker things `result` is an `int`, but it is a string\n  |\ninfo: rule `mutating-function-code-attribute` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Mutating __code__ attribute"],"tags":[]},{"location":"rules/mutating_function_code_attribute/#what-we-cant-catch","level":2,"title":"What we can't catch","text":"<p>Sometimes users will mutate <code>__code__</code> in a type safe way:</p> Python<pre><code>def foo(x: int) -&gt; int:\n    return 1\n\ndef bar(x: int) -&gt; int:\n    return 1\n\nfoo.__code__ = bar.__code__\n\nresult = foo(10)\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[mutating-function-code-attribute]: Mutating `__code__` attribute on a function may lead to runtime type errors.\n --&gt; main.py:7:1\n  |\n5 |     return 1\n6 |\n7 | foo.__code__ = bar.__code__\n  | ^^^^^^^^^^^^\n8 |\n9 | result = foo(10)\n  |\ninfo: rule `mutating-function-code-attribute` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p> <p>This is very hard to validate, and therefor we only emit a warning that you probably shouldn't be messing with the <code>__code__</code> attribute.</p>","path":["Mutating __code__ attribute"],"tags":[]},{"location":"rules/mutating_globals_dict/","level":1,"title":"Mutating <code>globals()</code> dict","text":"<p>Detects mutations to the <code>globals()</code> dictionary, which can bypass type checking and lead to runtime type errors.</p> <p>The <code>globals()</code> function returns a dictionary representing the current global symbol table. When you modify this dictionary directly, you can change the types of global variables at runtime without the type checker being aware of the change.</p>","path":["Mutating globals() dict"],"tags":[]},{"location":"rules/mutating_globals_dict/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>x: int = 5\n\nglobals()['x'] = \"hello\"\n\n# Type checker thinks `result` is an `int`, but it is a string\nresult: int = x\n</code></pre> Unsoundness Checker Output Text Only<pre><code>error[mutating-globals-dict]: Mutating the `globals()` dictionary may lead to runtime type errors.\n --&gt; main.py:3:1\n  |\n1 | x: int = 5\n2 |\n3 | globals()['x'] = \"hello\"\n  | ^^^^^^^^^^^^^^\n4 |\n5 | # Type checker thinks `result` is an `int`, but it is a string\n  |\ninfo: rule `mutating-globals-dict` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Mutating globals() dict"],"tags":[]},{"location":"rules/mutating_globals_dict/#what-is-okay","level":2,"title":"What is okay","text":"<p>If the type of the new value is assignable to the existing type of the symbol, we allow the mutation.</p> Python<pre><code>x: int = 1\n\n# `Literal[2]` is assignable to `int`\nglobals()[\"x\"] = 2\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["Mutating globals() dict"],"tags":[]},{"location":"rules/type_checking_directive_used/","level":1,"title":"Type checking directive used","text":"<p>Detects usage of type checking directives in comments, which suppress type checker warnings and may hide potential type errors.</p> <p>Type checking directives like <code># type: ignore</code> tell type checkers to skip validation of specific lines or sections of code. While sometimes necessary, they can mask real bugs that would otherwise be caught during static analysis.</p>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"<p>We detect directives from the major Python type checkers:</p>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#mypy-standard-pep-484","level":3,"title":"mypy / Standard (PEP 484)","text":"Python<pre><code>res = foo()  # type: ignore\n\nres = foo()  # type: ignore[name-defined]\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:1:14\n  |\n1 | res = foo()  # type: ignore\n  |              ^^^^^^^^^^^^^^\n2 |\n3 | res = foo()  # type: ignore[name-defined]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nwarning[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:3:14\n  |\n1 | res = foo()  # type: ignore\n2 |\n3 | res = foo()  # type: ignore[name-defined]\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#pyright","level":3,"title":"pyright","text":"Python<pre><code>res = foo()  # pyright: ignore\n\nres = foo()  # pyright: ignore[reportUndefinedVariable]\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[type-checking-directive-used]: Type checking directive `pyright: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:1:14\n  |\n1 | res = foo()  # pyright: ignore\n  |              ^^^^^^^^^^^^^^^^^\n2 |\n3 | res = foo()  # pyright: ignore[reportUndefinedVariable]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nwarning[type-checking-directive-used]: Type checking directive `pyright: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:3:14\n  |\n1 | res = foo()  # pyright: ignore\n2 |\n3 | res = foo()  # pyright: ignore[reportUndefinedVariable]\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#ty","level":3,"title":"ty","text":"Python<pre><code>res = foo()  # ty: ignore\n\nres = foo()  # ty: ignore[unresolved-reference]\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[type-checking-directive-used]: Type checking directive `ty: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:1:14\n  |\n1 | res = foo()  # ty: ignore\n  |              ^^^^^^^^^^^^\n2 |\n3 | res = foo()  # ty: ignore[unresolved-reference]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nwarning[type-checking-directive-used]: Type checking directive `ty: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:3:14\n  |\n1 | res = foo()  # ty: ignore\n2 |\n3 | res = foo()  # ty: ignore[unresolved-reference]\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#pyrefly","level":3,"title":"pyrefly","text":"Python<pre><code>res = foo()  # pyrefly: ignore\n\nres = foo()  # pyrefly: ignore[unknown-name]\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[type-checking-directive-used]: Type checking directive `pyrefly: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:1:14\n  |\n1 | res = foo()  # pyrefly: ignore\n  |              ^^^^^^^^^^^^^^^^^\n2 |\n3 | res = foo()  # pyrefly: ignore[unknown-name]\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n\nwarning[type-checking-directive-used]: Type checking directive `pyrefly: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:3:14\n  |\n1 | res = foo()  # pyrefly: ignore\n2 |\n3 | res = foo()  # pyrefly: ignore[unknown-name]\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#why-this-matters","level":2,"title":"Why this matters","text":"<p>Type checking directives bypass the safety guarantees that static type checking provides. For example:</p> Python<pre><code>def calculate_total(items: list[int]) -&gt; int:\n    return sum(items)\n\n# This will fail at runtime, but the directive hides the error\nresult = calculate_total(\"not a list\")  # type: ignore\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[type-checking-directive-used]: Type checking directive `type: ignore` suppresses type checker warnings, which may hide potential type errors.\n --&gt; main.py:5:41\n  |\n4 | # This will fail at runtime, but the directive hides the error\n5 | result = calculate_total(\"not a list\")  # type: ignore\n  |                                         ^^^^^^^^^^^^^^\n  |\ninfo: rule `type-checking-directive-used` was selected in the configuration file\n</code></pre>","path":["Type checking directive used"],"tags":[]},{"location":"rules/type_checking_directive_used/#when-directives-might-be-necessary","level":2,"title":"When directives might be necessary","text":"<p>There are legitimate cases where type checking directives are needed:</p> <ul> <li>Working with dynamic third-party libraries that lack type stubs</li> <li>Temporary workarounds during incremental type adoption</li> </ul> <p>However, these should be rare and well-documented exceptions, not the norm.</p>","path":["Type checking directive used"],"tags":[]},{"location":"rules/typing_any_used/","level":1,"title":"<code>typing.Any</code> used","text":"<p>Detects usage of <code>typing.Any</code> in type annotations, which can lead to runtime errors by bypassing type checking.</p> <p>When you use <code>Any</code>, you're essentially telling the type checker \"this could be anything,\" which defeats the purpose of having types in the first place. This can cause bugs that would otherwise be caught at development time.</p>","path":["typing.Any used"],"tags":[]},{"location":"rules/typing_any_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"<p>We currently detect <code>Any</code> in these places:</p>","path":["typing.Any used"],"tags":[]},{"location":"rules/typing_any_used/#function-parameters","level":3,"title":"Function parameters","text":"Python<pre><code>from typing import Any\n\ndef process_data(data: Any) -&gt; str:\n    return str(data)\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; main.py:3:24\n  |\n1 | from typing import Any\n2 |\n3 | def process_data(data: Any) -&gt; str:\n  |                        ^^^\n4 |     return str(data)\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.Any used"],"tags":[]},{"location":"rules/typing_any_used/#return-types","level":3,"title":"Return types","text":"Python<pre><code>from typing import Any\n\ndef get_user_data() -&gt; Any:\n    return {\"name\": \"John\", \"age\": 30}\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; main.py:3:24\n  |\n1 | from typing import Any\n2 |\n3 | def get_user_data() -&gt; Any:\n  |                        ^^^\n4 |     return {\"name\": \"John\", \"age\": 30}\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.Any used"],"tags":[]},{"location":"rules/typing_any_used/#variable-assignments","level":3,"title":"Variable assignments","text":"Python<pre><code>from typing import Any\n\ndef get_user() -&gt; dict[str, str | int]:\n    return {\"name\": \"John\", \"age\": 30}\n\nuser_info: Any = get_user()\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-any-used]: Using `typing.Any` in type annotations can lead to runtime errors.\n --&gt; main.py:6:12\n  |\n4 |     return {\"name\": \"John\", \"age\": 30}\n5 |\n6 | user_info: Any = get_user()\n  |            ^^^\n  |\ninfo: rule `typing-any-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.Any used"],"tags":[]},{"location":"rules/typing_cast_used/","level":1,"title":"<code>typing.cast</code> used","text":"<p>Detects usage of <code>typing.cast()</code> function calls, which can lead to runtime errors by bypassing type checking without any runtime validation.</p> <p><code>typing.cast()</code> tells the type checker to treat a value as a specific type without performing any runtime checks. Type checkers trust casts completely, so incorrect casts bypass all type safety guarantees.</p>","path":["typing.cast used"],"tags":[]},{"location":"rules/typing_cast_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>from typing import cast\n\ndef foo() -&gt; int:\n    return cast(int, \"hello\")\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-cast-used]: Using `typing.cast()` bypasses type checking and can lead to runtime type errors.\n --&gt; main.py:4:12\n  |\n3 | def foo() -&gt; int:\n4 |     return cast(int, \"hello\")\n  |            ^^^^\n  |\ninfo: Consider using `isinstance` checks to ensure types at runtime.\ninfo: rule `typing-cast-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.cast used"],"tags":[]},{"location":"rules/typing_cast_used/#better-alternative","level":2,"title":"Better alternative","text":"<p>Instead of using <code>cast()</code>, use <code>assert isinstance()</code> to validate types at runtime:</p> Python<pre><code>def get_value() -&gt; int | str:\n    return \"hello\"\n\nresult = get_value()\nassert isinstance(result, int)\n# Now we know it's safe - the assertion will catch incorrect types\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p> <p>This provides actual runtime safety instead of just lying to the type checker.</p>","path":["typing.cast used"],"tags":[]},{"location":"rules/typing_cast_used/#what-is-okay","level":2,"title":"What is okay","text":"<p>If the type of the value you are casting is assignable to the target type, it is okay to use <code>typing.cast()</code>.</p> Python<pre><code>from typing import cast\n\ndef foo() -&gt; int:\n    return cast(int, 1)\n</code></pre> <p>Unsoundness Checker: No Diagnostic Emitted</p> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.cast used"],"tags":[]},{"location":"rules/typing_overload_used/","level":1,"title":"<code>typing.overload</code> used","text":"<p>Detects use of overloaded functions.</p> <p>Overloaded functions can often lead to runtime errors if the implementations are not consistent with the overload definitions.</p> <p>We only emit a warning here as just using <code>typing.overload</code> will not necessarily lead to a runtime type error.</p>","path":["typing.overload used"],"tags":[]},{"location":"rules/typing_overload_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"<p>Here is an example of an overloaded function that is not implemented correctly, but type checkers will not emit diagnostics for this:</p> Python<pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; str: ...\n\n@overload\ndef foo(x: str) -&gt; int: ...\n\ndef foo(x: int | str) -&gt; str | int:\n    return x\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-overload-used]: Using `typing.overload` can lead to runtime errors.\n --&gt; main.py:3:1\n  |\n1 | from typing import overload\n2 |\n3 | @overload\n  | ^^^^^^^^^\n4 | def foo(x: int) -&gt; str: ...\n  |\ninfo: rule `typing-overload-used` was selected in the configuration file\n\nwarning[typing-overload-used]: Using `typing.overload` can lead to runtime errors.\n --&gt; main.py:6:1\n  |\n4 | def foo(x: int) -&gt; str: ...\n5 |\n6 | @overload\n  | ^^^^^^^^^\n7 | def foo(x: str) -&gt; int: ...\n  |\ninfo: rule `typing-overload-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.overload used"],"tags":[]},{"location":"rules/typing_type_is_used/","level":1,"title":"<code>typing.TypeIs</code> used","text":"<p>Detects usage of <code>typing.TypeIs</code> in return type annotations, which can lead to runtime errors if the type narrowing function is implemented incorrectly.</p> <p><code>typing.TypeIs</code> is used for type narrowing functions that tell type checkers to narrow the type of a variable. Type checkers trust TypeIs functions completely, so incorrect implementations bypass all type safety guarantees.</p>","path":["typing.TypeIs used"],"tags":[]},{"location":"rules/typing_type_is_used/#what-gets-flagged","level":2,"title":"What gets flagged","text":"Python<pre><code>from typing_extensions import TypeIs\n\ndef is_int(x: object) -&gt; TypeIs[int]:\n    return True\n\nvalue = \"hello\"\nif is_int(value):\n    # Type checker thinks value is int, but it's actually str\n    result = value + 1\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.\n --&gt; main.py:3:26\n  |\n1 | from typing_extensions import TypeIs\n2 |\n3 | def is_int(x: object) -&gt; TypeIs[int]:\n  |                          ^^^^^^^^^^^\n4 |     return True\n  |\ninfo: rule `typing-type-is-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.TypeIs used"],"tags":[]},{"location":"rules/typing_type_is_used/#better-alternative","level":2,"title":"Better alternative","text":"<p>Instead of using <code>TypeIs</code>, use <code>isinstance()</code> checks directly in your code:</p> <p>This provides actual runtime safety instead of just telling the type checker to trust your narrowing logic.</p>","path":["typing.TypeIs used"],"tags":[]},{"location":"rules/typing_type_is_used/#what-is-okay","level":2,"title":"What is okay","text":"<p>If your <code>TypeIs</code> function correctly validates the type at runtime, it should be safe. However, since there's no way for type checkers to verify the implementation matches the signature, it's easy to introduce bugs.</p> Python<pre><code>from typing_extensions import TypeIs\n\ndef is_int(x: object) -&gt; TypeIs[int]:\n    return isinstance(x, int)\n</code></pre> Unsoundness Checker Output Text Only<pre><code>warning[typing-type-is-used]: Using `typing.TypeIs` can lead to runtime type errors.\n --&gt; main.py:3:26\n  |\n1 | from typing_extensions import TypeIs\n2 |\n3 | def is_int(x: object) -&gt; TypeIs[int]:\n  |                          ^^^^^^^^^^^\n4 |     return isinstance(x, int)\n  |\ninfo: rule `typing-type-is-used` was selected in the configuration file\n</code></pre> <p>Mypy: No Diagnostic Emitted</p> <p>Pyright: No Diagnostic Emitted</p> <p>Ty: No Diagnostic Emitted</p>","path":["typing.TypeIs used"],"tags":[]}]}